<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>CMPS 260: Module 3 Homework</title>
<style>* { font-family: monospace; }</style>
<script>
//--------------------------//
// The stack data structure //
//--------------------------//
console.log("The stack data structure");

// 1. Implement the stack data structure using the prototype (as opposed to the
//    version we wrote in class).

function Stack() {
  // properties are initialized here
}

// methods go here using Stack.prototype.
var items = [];
Stack.prototype.push = function(element) {
  items.push(element);
}
Stack.prototype.pop = function() {
  return items.pop();
}
Stack.prototype.peek = function() {
  return items[items.length - 1];
}
Stack.prototype.isEmpty = function() {
  return items.length === 0;
}
Stack.prototype.size = function() {
  return items.length;
}
Stack.prototype.clear = function() {
  items = [];
}
Stack.prototype.print = function() {
  console.log(items.toString());
}

// 2. Write a simple test program that shows your stack works.
var stack = new Stack();
stack.push(7);
stack.push(3);
stack.push(5);
stack.print();
// 3. Add a method to Stack that returns the largest value on the stack. Return
//    null if there are no elements on the stack. Show that your method works.
Stack.prototype.largest = function() {
  this.large = items[0];
  for (var i = 0; i < items.length; i++) {
    if (items[i] - this.large > 0) {
      this.large = items[i];
    }
  }
  console.log(this.large);
}
stack.largest(); //Expect 7
stack.push(9);
stack.largest(); //Expect 9

//----------------------------------//
// ECMAScript 6 and the Stack class //
//----------------------------------//
console.log("ECMAScript 6 and the Stack class");

// Skip.



//-------------------------------//
// Solving problems using stacks //
//-------------------------------//
console.log("Solving problems using stacks");

// See Project.



//---------//
// Project //
//---------//
console.log("Project");

// 1. It is possible to use a stack to check if the number of parentheses in a
//    string is balanced, meaning there are as many opening parentheses as
//    closing ones. In addition, we can also make sure that each opening
//    parenthesis precedes a closing parenthesis. Implement this algorithm.
//    HINT: When encountering '(' push to the stack and when encountering ')'
//    pop from the stack.

function isBalanced(str) {
  var strStack = [];
  var map = {
    '(': ')',
    '[': ']',
    '{': '}'
  };
  for (var i = 0; i < str.length; i++) {
    if (str[i] === '(' || str[i] === '{' || str[i] === '{') {
      strStack.push(str[i]);
    }
    else {
      var last = strStack.pop();
      if (str[i] !== map[last]) {
        return false;
      }
    }
  }
  if (strStack.length !== 0) {
    return false;
  }
  return true;
}
console.log(isBalanced('({[]})]')) //Expect false
console.log(isBalanced('()[]{}')) //Expect true
console.log(isBalanced('[]()()')) //Expect true
console.log(isBalanced('((({[]]()})))')) //Expect false

// 2. Write a simple test program that shows your implementation works.



</script>
</head>
<body>
  See console!
</body>
</html>
